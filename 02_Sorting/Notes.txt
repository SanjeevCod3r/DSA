Quick Sort:
------------
QuickSort is a divide-and-conquer sorting algorithm that works by selecting a pivot element, 
partitioning the array around the pivot, and recursively sorting the subarrays.

1. How QuickSort Works:

ğŸ“Choose a Pivot (can be the first, last, middle, or a random element).
ğŸ“Partition the Array:
    -> Move elements smaller than the pivot to the left.
    -> Move elements larger than the pivot to the right.
ğŸ“Recursively Apply QuickSort to left and right subarrays.

3. Time Complexity Analysis:
Best Case -> O(n log n)	-> When the pivot divides the array into two equal halves at each step.
Average Case -> O(n log n) -> Most random distributions result in balanced partitions.
Worst Case -> O(nÂ²) -> Occurs when the smallest or largest element is always chosen as the pivot (highly unbalanced partitions).

4. Space Complexity:
-> O(log n) for recursion stack in the average case.
-> O(n) in the worst case (if partitioning is highly unbalanced).

5. Stability:
Not stable â†’ Relative order of equal elements may change.
Alternative â†’ Merge Sort is stable.

6. Advantages of QuickSort:
âœ… Fast on Average â€“ O(n log n) in most cases.
âœ… In-Place Sorting â€“ Uses less memory than Merge Sort.
âœ… Efficient for Large Datasets â€“ Used in real-world applications.

7. Disadvantages of QuickSort:
âŒ Worst Case is O(nÂ²) â€“ If the pivot is poorly chosen.
âŒ Not Stable â€“ May not preserve duplicate order.
âŒ Recursion Overhead â€“ Can cause stack overflow for large arrays.


Merge Sort:
-----------
Merge Sort is a divide-and-conquer sorting algorithm that recursively divides the array into two halves, 
sorts them, and then merges them back together.

1. How Merge Sort Works:
-> Divide: Split the array into two halves until each subarray contains only one element.
-> Conquer: Recursively sort both halves.
-> Merge: Combine the two sorted halves into a single sorted array.

3. Time Complexity Analysis:
Best Case ----> O(n log n) ---> Recursively dividing into halves and merging
Average Case ----> O(n log n) ---->	Works consistently for random data
Worst Case ----> O(n log n) ----> Even if the array is sorted or in reverse order, it always divides

4. Space Complexity:
O(n) â†’ Requires extra space for temporary arrays during merging.
Unlike QuickSort (O(log n) space), Merge Sort is not an in-place sorting algorithm because it requires additional memory.

5. Stability:
âœ… Merge Sort is stable â†’ It preserves the relative order of equal elements.
âŒ QuickSort is unstable unless modified.
Example:
Input:  [5A, 2, 5B, 1]
Sorted: [1, 2, 5A, 5B]  âœ… (5A remains before 5B)

6. Advantages of Merge Sort:
âœ… Guaranteed O(n log n) time complexity
âœ… Stable sorting algorithm
âœ… Works well for large datasets and linked lists

7. Disadvantages of Merge Sort:
âŒ Requires extra space (O(n)) â†’ Not in-place sorting
âŒ Slower for small arrays â†’ Insertion Sort is faster for small datasets








